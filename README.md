# Introduction
## Reason:
Often times programming languages use a "virtual machine", although it only [virtualizes the cpu without an operating system making it not a virtual machine](https://stackoverflow.com/questions/861422/is-java-virtual-really-a-virtual-machine-in-the-same-sense-as-my-vmw), and on top of that web browsers are starting acting more like a virtual machine after the w3c adoption of webassembly. With those facts, and failing to understand Linux's source code.
## What is it:
Samsara is a hybrid kernel that can have drivers run in either user space, in kernel space, or in the levels in between (see the Frameworks section in the Features. It is also an interpreter and compiler for rust (it will probably be changed to a custum language).

# Features for Samsara
- **Compilation and Interpretation and Virtualization:** Samsara will act as an interpeter and compiler on top of its kernel duties. As of now three languages are planned to be supported: A low level language in wich the kernel is written in that can also be used to write script extensions in the vein of the Extended Berkely Packet Filter (this is going to be Rust for now); a bytecode language in which binaries can be compiled to that allows for the platform independence for the kernel to run as a type one hypervisor; a query style scripting language which is interpreted directly by the kernel (probably implemented using Rust macros). The memory manager might be given the ability to rewrite pages being loaded to memory to allow for programs written in different binaries to be ran and allow for virtualization and non-cooperative multitasking (see Process Handling) even when the hardware does not support it.
- **Drives and Files:** An extension to Redox's "everything is a url" which is an extension of Unix's "everything is a file". Both physical drives and virtual drives can be mounted. Virtual drives can hold and generate resources and contain processes. Service processes are often put into a drive with related services, in which case that drive is called a server. Drives can also serve as a application container and even a virtual machine as well.
- **Frameworks:** *Shell frameworks/userland frameworks* are how the userland is organized and interfaces with the kernel. The init system sets up the framework by using system calls to configure the interface files, the shell language and libraries and the protection rings. Samsara has the abillity to utilize multiple protection rings and run system applications in those protection rings: run all system services in ring 2 and drivers in ring 1, run drivers and services in ring 1, run only drivers in ring 1, run the drivers in ring 0 (kernel space) and run everything else in ring 3 (user space) like most monolithic kernels, run everything that is not the kernel in ring 3 like most microkernels, or run everything in ring 0 (kernel space) "...by choice because it's fun" (Terry Davis according to Jeff Delaney of Fireship), and any kind of weird variation in between. Other things that can be controlled when setting up the framework include: setting up shell scripting language, setting up shell libraries, setting up virtualization, enabling/disabling certain features, registering certain kernel level modules and deciding how the ebpf will work, and many more things.
- **Process Handling and Robustness**: Since Samsara is written in Rust (at least initially), there is probably going to be a lot of robustness built into the multithreaded programing already; however this will be added on to by following some of Erlang's process specifications. For starters there will be a thread per core called a *kernel thread*. Each kernel thread will be given a set of task to execute from the scheduler. Each of the Samsara subsystems as well as any kernel level modules will be considered a *kernel process*. The kernel processes will be given a kernel thread to run on by the scheduler, which itself runs on the kernel thread 0, and the will create tasks for that thread to run. Outside of kernel space (ring 0) Processes will be mostly standard user processes with one or more green threads. Since most processors have interrupts, the scheduler will run in preimptive multitasking where user threads will run directly on the hardware until interrupted, in which a kernel level task can run in and the next user thread can be ran, but if for some reason there is not hardware level interrupts then the scheduler can run in cooperative multitasking, or run a task based multitasking, where the scheduler works with the memory manager to break up the text that the user level threads execute into task pages with a jump at the that gives the control back to the scheduler once it is finished (I understand the security risks this poses and am thinking of a solution which might include just warning against it, or even using the memory manager's page rewriting system to change the instructions, see the Interpetation section). Although most of the process and thread handling will follow the unix family way there will be some add features: all negative pid will be kernel level processes with the scheduler having pid -1, the abillity to combine signals and messages, and lightweight processes that can be spawned with a small task to execute or spawned by a task pool for other processes to insert tasks into.

# Sources
- [Philipp Opperman's Rust Kernel Blog](https://os.phil-opp.com/minimal-rust-kernel/)
- (Ed of Low Level Learning's "rust runs on Everything \(no operating system, just rust\))[https://www.youtube.com/watch?v=jZT8APrzvc4&list=TLPQMDcwODIwMjTLmLbfX5NDPA&index=1]
