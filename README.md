# Introduction
## What is it:
Samsara is hybrid, semi-language based, protocol heavy kernel. Samsara has many different modes and settings allowing for flexibility and customization, with some examples being: deciding what space services and drivers run at, changing the type of multitasking, virtualization, amoung other things.
## Reason:
One day I downloaded the source code for linux to look through, and could not understand what I was seeing, so to learn how a kernel works I decided o make one. There were other ideas I wanted to explore too: virtualization and language based machines, protocols and the client-server model, and robust concurrency using message passing and supervisor tree. Starting off with virtualization often times a programming language uses a virtual machine \([this stackoverflow post](https://stackoverflow.com/questions/861422/is-java-virtual-really-a-virtual-machine-in-the-same-sense-as-my-vmw) says that they are not true virtual machines because they only virtualize the processor, but I disagree\), this includes web browsers: despite being interpreters for html, css, and javascript, they are starting acting more like a virtual machines and even full fledged operating systems, especially after the w3c adoption of webassembly. To further the comparison, the server client model is often used for linking different pieces of one machine, with certain protocol defining there behavior towards each other: display servers are a good example with Wayland being a nothing more than a protocol for applications to interact with a display server. All of these ideas seem interesting enough to explore which is the big motivator to make the kernel.

# Features for Samsara
- **Virtualization and Language-Bases:** The memory manager doubles as a virtual machine and can even serve as a backend for interpreters/compiliers allowing for the kernel to run as a language-based system. This is all acheived by the memeory managers page editing capabilities.
- **Everything is a Url:** Inspired by Redox OS's schemes and Bell Lab's Plan 9  style namespaces, Samsara uses an abstraction of file storage drives, named virtual drives, or drives, to not only represent real drives and devices, but also group together resources and provide an interface for those resources, especially in the context of containers and virtual machines, which are often virtual derives.
- **Robust Concurrency**: Samsara uses mostly immutable model of concurrency inspired by Erlang, with message passing that is inspired from the network stack. When a process wants to communicate with a another it sends a message packet to the processes' mailbox, which is of course a file. In addition a processes can have different multiple mailboxes that take different types of messages; this is how Unix IPC (interpocess communication), exempting shared memory and semaphores, is implemented: pipes, fifos, message queues and domain sockets are all just different types of mailboxes, and signals are just message packets sent to the kernel's mailbox with information about a process and the interger of the signal. Another feature taken from Erlang is the supervisor tree: A kernel level module process will create a bunch of worker threads to execute needed task and will handle any failure from the worker. Kernel level processes can also be communicated using negative pids which are either a flag or a signed integer (see Process Scheduler Manager section in the Systems of Samsara).
- **Modifiable User Space:** The structure of the userspace, known as *Shell Frameworks/Userland Frameworks*, is very customizable and is decided by the init system, mostly on startup (some things can be modified while running). Drivers and even services can be ran in userspace (ring 3), kernel space (ring 0) or the space(s) inbetween (rings 1 and 2), and API/ABIs can be also put inbetween the spaces as a shell layer, and even the kernel syscalls can be remapped, and the shell be swapped out.
# Systems of Samsara
## Modules:
Samsara is a hybrid kernel, and thus very modular. The kernel can be packaged with few or many modules, and it can be decided which modules are actually loaded into the kernel. The only modules that are necessary are the three core modules listed below, everything else is secondary. There are two types of modules: executing, generally drivers and the core modules, and non-executing, generally support modules and setting modules. Executing modules are registered with the scheduler (see Process Schedule Manager in the core section) and are considered a kernel level process, whereas non-executing modules are not registered with the scheduler. All executing modules need to follow a supervisior tree style architecture: most of the work is done by worker threads executing jobs given to them by there parent process, referred to as the supervisior, that then handles errors and exceptions. Modules follow this by providing tasks to the scheduler which it then puts on worker threads. This supervisor tree always has the executing module as the top supervisor, with worker threads running supervising tasks and support/sub modules as intermediate supervisors to provide robustnes. 
### Arch:
Only somewhat considered a module. This (semi)module will contain alll most of the assembly required by the architecture. The kernel can also act as a bootloader, in which case arch will contain all the code for that: the rust code compiled for bios and 16 bit real mode and all the necessary assembly. Arch also contains the trait definitions for which the core modules need to implement.
### Core (Primary):
Samsara has 3 core subsytems: the **Process Schedule Manager (PSM)**, the **Memory Page Manager (MPM)**, and the **File Resource Manager (FRM)**. As stated in the features section, kernel level processes can be identified with a negative pid, and the PSM will always have a PID -1, followed by the MPM as pid -2 and the FRM as pid -3. All other executing modules are given pids -4 onward depending on there order they are loaded. The negative pid can be stored in one of two formats:the pid being an unsigned integer with a flag bit to tell wether or not the process is a kernel level module or in a two compliment signed integer where the flag is mapped to the signed bit. 
1. **Process Schedule Manager (PSM)**: Schedules the processes and manages there interactions. Interprocess communication is usually facilitated by a process sending message packets from a mailbox that it owns to a mailbox of the target processes(s). A process can have many mailboxes and a mailbox can have many processes. In addition mailboxes can have a type of message they receive (they often do). Most of the Unix ipc primitives, exempting semaphores and shared memory is implemented as message packets: Sockets, fifos, pipes and message queues are all different types of mailboxes, and signals are messages sent directly to the kernel with the payload being the signal number and the target process. Thes messages can also be passed over network, in which case it can be referred to as the Process Message Transfer Protocol (PMTP), which allows for remote processes to be interact with as if they are local.
2. **Memory Page Manager (MPM)**: the MPM manages memory and provides instruction replacement, hardware abstraction layers (HALs), and even translation for higher level languages. The MPM uses page editing to change the contents of the memory page: rewriting the instructions in the text page, rerouting pointers, resizing memory, etc. This feature can allow for software level interrupts and full hardware virtualization, amoung other things.
3. **File Resource Manager (FRM)**: Manages and keeps track of resources. The FRM barrows ideas from Plan 9 and Redox OS (which also barrows from Plan 9) and implements them as virtual drives: any mounted resource "looks like" a storage drive with its own filesystem. All devices: graphics cards, sound cards, network cards, etc., are mounted and then appear as drives, with the driver providing an interface in the form of files inside that drive. Virtual drives can also be used to group resources together and is the basis for containers and virtual machines. All drives, virtual and real, and the resources can be accessed either through an absolute path or a relative path using there name followed by a colon and a forward slash (e.g. "/mount/nvme1/homework/essay.txt" or "nvme:/homework/essay.txt").
### Secondary:
Many modules can be added to the kernel to provide extra functionality, provide compatibility in the form of drivers, or lock down settings without using setting modules without using the init system.
## Userpace Framework
Like all other Unix-like operating systems, Samsara starts the init system which starts every other process. However the init system is also tasked with setting up the userspace, which is done mostly on startup by mounting resources and changing runtime settings in the kernel. The biggest change by far is deciding what drivers and services are ran and where. On boot the kernel loads its core modules, then secondary module, then the init system which then then loads any userpace level drivers and services and tells the kernel where it would like them to run and even to unload certain modules. The places the init system can put drivers and services, including itself, are: in kernel space (ring 0), userspace (ring 3) or the ring(s) inbetween (1 and 2). If a ring is used inbetween userspace and kernel space then an api/abi can be provided to act as shell (this is not necessary as the ipc can also be used). The init system can also reconfigure how the kernel behaves by talking to the core modules: requesting the PSM remove itself from the process table will make the kernel run in cooperative multasking mode, a request to the MPM can be made to run the kernel in the language-based mode, and specific mounting can change how the request can change how the file hierachy is organized. Many of these features can also be locked down by changing flags in the source code or installing a setting module that changes the flags.

# Sources
- [Philipp Opperman's Rust Kernel Blog](https://os.phil-opp.com/minimal-rust-kernel/)
- [Ed of Low Level Learning's "rust runs on Everything (no operating system, just rust)"](https://www.youtube.com/watch?v=jZT8APrzvc4&list=TLPQMDcwODIwMjTLmLbfX5NDPA&index=1)
- [Nir Lichtman's "Making a Bootloader using x86 Assembly](https://www.youtube.com/watch?v=xFrMXzKCXIc&list=TLPQMjcwODIwMjSPG5-G91fv2Q&index=3)
- [Redox OS](https://www.redox-os.org)
- Wikipedia on everything from plan 9, Unix/POSIX standards, Linux, language-based operating systems and more.
- [Masen's "How to make a simple boot loader that reas a kernel into memory!](https://www.youtube.com/watch?v=6gLHG0qZ8HA&t=368s)
- [Osdev wiki](https://wiki.osdev.org/Expanded_Main_Page)
- [Sphaerophoria's "Learning (and inferring) about OS bootstrapping"](https://youtu.be/gBykJMqDqH0?si=_8D6gCtjA29q67o0)
- [Sphaerophoria's "Parsing info from bootloader in rust kernel"](https://youtu.be/WBDjsYnhaKI?si=JYO2hnj0MDo8nsHu)
- [Queso Fuego's "UEFI Programming in c" playlist](https://youtube.com/playlist?list=PLT7NbkyNWaqZYHNLtOZ1MNxOt8myP5K0p&si=6n0UO7NrDC6-yDsX)
